// Code generated by oto; DO NOT EDIT.

use serde_json::{Map, Value};

pub trait Backend: Send + Sync {
    fn run(&self, req: RunRequest) -> Result<RunResponse, String>;
    fn test(&self, req: TestRequest) -> Result<TestResponse, String>;
}

#[derive(Serialize, Deserialize)]
pub struct GromacsConfig {
    pub num_steps: i64,
    pub integrator: String,
    pub seed: i64,
    pub delta_time: f64,
    pub out_steps: i64,
    pub couple_intramol: bool,
    pub stop_tolerance: f64,
}

impl GromacsConfig {
    pub fn new() -> Self {
        GromacsConfig {
            num_steps: Default::default(),
            integrator: Default::default(),
            seed: Default::default(),
            delta_time: Default::default(),
            out_steps: Default::default(),
            couple_intramol: Default::default(),
            stop_tolerance: Default::default(),
        }
    }

    pub fn make(
        num_steps: i64,
        integrator: String,
        seed: i64,
        delta_time: f64,
        out_steps: i64,
        couple_intramol: bool,
        stop_tolerance: f64,
    ) -> Self {
        GromacsConfig {
            num_steps,

            integrator,

            seed,

            delta_time,

            out_steps,

            couple_intramol,

            stop_tolerance,
        }
    }
}

impl Default for GromacsConfig {
    fn default() -> GromacsConfig {
        GromacsConfig::new()
    }
}

#[derive(Serialize, Deserialize)]
pub struct RunRequest {
    pub structure_ids: Vec<String>,
    pub backend: String,
    pub config: Map<String, Value>,
    pub gromacs: Vec<GromacsConfig>,
}

impl RunRequest {
    pub fn new() -> Self {
        RunRequest {
            structure_ids: Default::default(),
            backend: Default::default(),
            config: Default::default(),
            gromacs: Default::default(),
        }
    }

    pub fn make(
        structure_ids: Vec<String>,
        backend: String,
        config: Map<String, Value>,
        gromacs: Vec<GromacsConfig>,
    ) -> Self {
        RunRequest {
            structure_ids,

            backend,

            config,

            gromacs,
        }
    }
}

impl Default for RunRequest {
    fn default() -> RunRequest {
        RunRequest::new()
    }
}

#[derive(Serialize, Deserialize)]
pub struct RunResponse {
    error: Option<String>,
}

impl RunResponse {
    pub fn new() -> Self {
        RunResponse { error: None }
    }

    pub fn make() -> Self {
        RunResponse { error: None }
    }

    pub fn error(msg: String) -> Self {
        RunResponse { error: Some(msg) }
    }

    pub(crate) fn is_error(&self) -> bool {
        self.error != None
    }

    pub(crate) fn get_error(&self) -> Option<&String> {
        self.error.as_ref()
    }

    pub(crate) fn take_error(&mut self) -> Option<String> {
        self.error.take()
    }
}

impl Default for RunResponse {
    fn default() -> RunResponse {
        RunResponse::new()
    }
}

#[derive(Serialize, Deserialize)]
pub struct TestRequest {}

impl TestRequest {
    pub fn new() -> Self {
        TestRequest {}
    }

    pub fn make() -> Self {
        TestRequest {}
    }
}

impl Default for TestRequest {
    fn default() -> TestRequest {
        TestRequest::new()
    }
}

#[derive(Serialize, Deserialize)]
pub struct TestResponse {
    error: Option<String>,
}

impl TestResponse {
    pub fn new() -> Self {
        TestResponse { error: None }
    }

    pub fn make() -> Self {
        TestResponse { error: None }
    }

    pub fn error(msg: String) -> Self {
        TestResponse { error: Some(msg) }
    }

    pub(crate) fn is_error(&self) -> bool {
        self.error != None
    }

    pub(crate) fn get_error(&self) -> Option<&String> {
        self.error.as_ref()
    }

    pub(crate) fn take_error(&mut self) -> Option<String> {
        self.error.take()
    }
}

impl Default for TestResponse {
    fn default() -> TestResponse {
        TestResponse::new()
    }
}

pub mod mock {
    use super::*;

    pub struct MockBackend {
        error: Option<&'static str>,
    }

    impl MockBackend {
        pub fn new() -> MockBackend {
            MockBackend { error: None }
        }

        pub fn error(message: &'static str) -> MockBackend {
            MockBackend {
                error: Some(message),
            }
        }
    }

    impl Backend for MockBackend {
        fn run(&self, _: RunRequest) -> Result<RunResponse, String> {
            match self.error {
                Some(msg) => Err(String::from(msg)),
                None => Ok(Default::default()),
            }
        }

        fn test(&self, _: TestRequest) -> Result<TestResponse, String> {
            match self.error {
                Some(msg) => Err(String::from(msg)),
                None => Ok(Default::default()),
            }
        }
    }
}

#[cfg(test)]
mod test {
    use super::mock::*;
    use super::*;

    mod backend {
        use super::*;

        #[test]
        fn test_run_ok() {
            assert!(MockBackend::new().run(Default::default()).is_ok());
        }

        #[test]
        #[should_panic]
        fn test_run_error() {
            MockBackend::error("quaranstream")
                .run(Default::default())
                .expect("should panic because its an error");
        }

        #[test]
        fn test_test_ok() {
            assert!(MockBackend::new().test(Default::default()).is_ok());
        }

        #[test]
        #[should_panic]
        fn test_test_error() {
            MockBackend::error("quaranstream")
                .test(Default::default())
                .expect("should panic because its an error");
        }
    }
}
