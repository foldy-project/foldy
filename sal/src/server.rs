// Code generated by oto; DO NOT EDIT.
//
// Instructions for Rocket Server https://rocket.rs/
//
// Add the following dependencies to Cargo.toml:
//
//      [dependencies.rocket]
//      version = "0.4.4"
//
//      [dependencies.rocket_contrib]
//      version = "0.4.4"
//      default-features = false
//      features = ["json"]
//
// Add the following crate declarations to your main.rs:
//
//      #![feature(proc_macro_hygiene, decl_macro)]
//      #[macro_use] extern crate rocket;
//      #[macro_use] extern crate rocket_contrib;
//      #[macro_use] extern crate serde_derive;
//
// Also in main.rs, include the generated modules:
//
//      mod server;
//      mod types;
//      ...
//      use crate::server::*;
//      use crate::types::*;
//      ...
//
// Make sure to run `cargo test` to ensure the mock implementation works.
//

use crate::types::*;
use rocket::config::{Config, Environment};
use rocket::data::{FromDataSimple, Outcome};
use rocket::http::{ContentType, Status};
use rocket::response::{self, Responder, Response};
use rocket::{Data, Outcome::*, Request, State};
use rocket_contrib::json::JsonValue;
use serde_json;
use std::io::Cursor;
use std::io::Read;

fn error_json(msg: &str) -> String {
    format!("{{\"error\":\"{}\"}}", msg)
}

#[post("/")]
fn index() -> &'static str {
    "It works!"
}

#[catch(400)]
fn bad_request(_: &Request) -> JsonValue {
    json!({"error": "error deserializing request"})
}

#[post("/Backend.Run", format = "json", data = "<data>")]
fn backend_run(data: RunRequest, svc: State<Box<dyn Backend>>) -> RunResponse {
    match svc.run(data) {
        Ok(resp) => resp,
        Err(msg) => RunResponse::error(msg),
    }
}

pub struct BackendServer {
    rocket: rocket::Rocket,
}

impl BackendServer {
    pub fn new(svc: Box<dyn Backend>) -> Self {
        BackendServer::make(svc, "0.0.0.0", 8000)
    }

    pub fn make(svc: Box<dyn Backend>, address: &str, port: u16) -> Self {
        let config = Config::build(Environment::Staging)
            .address(address)
            .port(port)
            .unwrap();
        let rocket = rocket::custom(config)
            .register(catchers![bad_request])
            .mount("/oto", routes![index, backend_run,])
            .manage(svc);
        BackendServer { rocket }
    }

    pub fn listen(self) -> rocket::error::LaunchError {
        self.rocket.launch()
    }
}

impl FromDataSimple for GromacsConfig {
    type Error = String;

    fn from_data(req: &Request, data: Data) -> Outcome<Self, String> {
        let json_ct = ContentType::new("application", "json");
        if req.content_type() != Some(&json_ct) {
            return Outcome::Forward(data);
        }
        let mut body = String::new();
        if let Err(e) = data.open().read_to_string(&mut body) {
            return Failure((Status::InternalServerError, format!("{:?}", e)));
        }
        match serde_json::from_str::<GromacsConfig>(&body) {
            Ok(value) => Success(value),
            Err(e) => Failure((Status::BadRequest, format!("{:?}", e))),
        }
    }
}

impl FromDataSimple for RunRequest {
    type Error = String;

    fn from_data(req: &Request, data: Data) -> Outcome<Self, String> {
        let json_ct = ContentType::new("application", "json");
        if req.content_type() != Some(&json_ct) {
            return Outcome::Forward(data);
        }
        let mut body = String::new();
        if let Err(e) = data.open().read_to_string(&mut body) {
            return Failure((Status::InternalServerError, format!("{:?}", e)));
        }
        match serde_json::from_str::<RunRequest>(&body) {
            Ok(value) => Success(value),
            Err(e) => Failure((Status::BadRequest, format!("{:?}", e))),
        }
    }
}

impl FromDataSimple for RunResponse {
    type Error = String;

    fn from_data(req: &Request, data: Data) -> Outcome<Self, String> {
        let json_ct = ContentType::new("application", "json");
        if req.content_type() != Some(&json_ct) {
            return Outcome::Forward(data);
        }
        let mut body = String::new();
        if let Err(e) = data.open().read_to_string(&mut body) {
            return Failure((Status::InternalServerError, format!("{:?}", e)));
        }
        match serde_json::from_str::<RunResponse>(&body) {
            Ok(value) => Success(value),
            Err(e) => Failure((Status::BadRequest, format!("{:?}", e))),
        }
    }
}

impl<'a> Responder<'a> for RunResponse {
    fn respond_to(self, _: &Request) -> response::Result<'a> {
        let (status, body) = match self.is_error() {
            true => (
                Status::InternalServerError,
                error_json(self.get_error().unwrap()),
            ),
            false => match serde_json::to_string(&self) {
                Ok(body) => (Status::Ok, body),
                Err(e) => {
                    let msg = format!("{}", &e);
                    (Status::InternalServerError, error_json(&msg))
                }
            },
        };
        Response::build()
            .header(ContentType::JSON)
            .status(status)
            .sized_body(Cursor::new(body))
            .ok()
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::types::mock::*;
    use rocket::local::Client;

    #[test]
    fn test_backend_run_ok() {
        let server = BackendServer::new(Box::new(MockBackend::new()));
        let client = Client::new(server.rocket).expect("valid rocket instance");
        let req = RunRequest::new();
        let body = serde_json::to_string(&req).unwrap();
        let mut response = client
            .post("/oto/Backend.Run")
            .header(ContentType::JSON)
            .body(body)
            .dispatch();
        assert_eq!(response.status(), Status::Ok);
        assert_eq!(response.content_type(), Some(ContentType::JSON));
        let expected = RunResponse::new();
        let expected_json = serde_json::to_string(&expected).unwrap();
        assert_eq!(response.body_string(), Some(expected_json.into()));
    }

    #[test]
    fn test_backend_run_error() {
        let server = BackendServer::new(Box::new(MockBackend::error("purple")));
        let client = Client::new(server.rocket).expect("valid rocket instance");
        let req = RunRequest::new();
        let body = serde_json::to_string(&req).unwrap();
        let mut response = client
            .post("/oto/Backend.Run")
            .header(ContentType::JSON)
            .body(body)
            .dispatch();
        assert_eq!(response.status(), Status::InternalServerError);
        assert_eq!(response.content_type(), Some(ContentType::JSON));
        assert_eq!(
            response.body_string(),
            Some("{\"error\":\"purple\"}".into())
        );
    }

    #[test]
    fn test_backend_run_bad_request() {
        let server = BackendServer::new(Box::new(MockBackend::error("purple")));
        let client = Client::new(server.rocket).expect("valid rocket instance");
        let mut response = client
            .post("/oto/Backend.Run")
            .header(ContentType::JSON)
            .body(String::from("asdjfmmvzzi"))
            .dispatch();
        assert_eq!(response.status(), Status::BadRequest);
        assert_eq!(
            response.body_string(),
            Some("{\"error\":\"error deserializing request\"}".into())
        );
    }
}
